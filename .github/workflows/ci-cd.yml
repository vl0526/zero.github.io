name: CI/CD

# Trigger the workflow on pushes to any branch
on: [push]

jobs:
  build-and-deploy:
    # Run the job on an Ubuntu latest runner
    runs-on: ubuntu-latest

    steps:
      # Checkout the source code
      - uses: actions/checkout@v3

      # Set up Node.js environment
      - uses: actions/setup-node@v3
        with:
          node-version: '18' # Use Node.js version 18

      # --- Frontend Build (if needed) ---
      # This example assumes the frontend is a static site served separately
      # or built as part of the backend image. If you have a complex frontend
      # build process (e.g., React, Vue), you'd add those steps here.
      - name: Install frontend dependencies
        working-directory: ./frontend
        run: npm ci
      - name: Build frontend (Placeholder)
        working-directory: ./frontend
        # If your frontend needs a build step (like Webpack), replace this echo
        # run: npm run build
        run: echo "Frontend build step placeholder: Static site served by backend or CDN"

      # --- Backend Build ---
      - name: Install backend dependencies
        working-directory: ./backend
        run: npm ci
      - name: Build backend TypeScript
        working-directory: ./backend
        run: npm run build

      # --- Docker Build & Deploy to Cloud Run ---
      # Authenticate to Google Cloud using Workload Identity Federation
      - name: Authenticate to GCP
        uses: google-github-actions/auth@v1
        with:
          # Your Workload Identity Provider resource name
          workload_identity_provider: ${{ secrets.WORKLOAD_IDENTITY_PROVIDER }}
          # Your GCP service account email
          service_account: ${{ secrets.GCP_SA_EMAIL }}

      # Configure Docker to use gcloud as a credential helper
      - name: Configure Docker
        run: gcloud auth configure-docker

      # Build the Docker image and push it to Google Container Registry (GCR)
      - name: Build & push Docker image
        run: |
          # Build the image with a tag including the GCP project ID
          docker build -t gcr.io/${{ secrets.GCP_PROJECT }}/subtitle-backend:latest backend
          # Push the image to GCR
          docker push gcr.io/${{ secrets.GCP_PROJECT }}/subtitle-backend:latest

      # Deploy the Docker image to Google Cloud Run
      - name: Deploy to Cloud Run
        run: |
          gcloud run deploy subtitle-backend \
            --image gcr.io/${{ secrets.GCP_PROJECT }}/subtitle-backend:latest \
            --region=asia-east2 \
            --platform=managed \
            --allow-unauthenticated \
            --set-secrets=GEMINI_API_KEY=${{ secrets.GEMINI_SECRET_NAME }} \
            --timeout=300s # Increase timeout if transcription is long

      # NOTE: The --set-secrets flag directly injects the secret value as an environment variable.
      # The backend code (backend/src/index.ts and worker.ts) should read GEMINI_API_KEY from process.env.
      # The original code used getSecret from secrets.ts which is more secure as it accesses the secret
      # at runtime via the Secret Manager API, leveraging the service account's permissions.
      # Using --set-secrets is simpler but less secure if the environment variable is accidentally logged.
      # For better security, configure the Cloud Run service account with permissions
      # to access the Secret Manager secret and use the getSecret function in your backend code.
      # If using getSecret, remove the --set-secrets flag from the gcloud run deploy command.
      # Ensure the service account used by Cloud Run has the `Secret Manager Secret Accessor` role.
