<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SuperPro Video Thumbnail Generator-01</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
  <style>
    * { box-sizing: border-box; }
    body { margin: 0; font-family: 'Roboto', sans-serif; background: #121212; color: #fff; display: flex; flex-direction: column; align-items: center; padding: 20px; }
    h1 { margin-bottom: 10px; }
    .container { max-width: 800px; width: 100%; }
    .input-group { margin-bottom: 20px; display: flex; flex-wrap: wrap; gap: 10px; align-items: center; justify-content: center; }
    input[type="file"], select { padding: 8px; border-radius: 4px; border: none; }
    button { padding: 10px 20px; background: #00aaff; border: none; border-radius: 4px; color: #fff; cursor: pointer; font-weight: bold; }
    button:hover { background: #008ecc; }
    #loader { margin: 10px; font-size: 16px; }
    #thumbnails { display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 20px; justify-content: center; }
    #thumbnails img { width: 150px; height: auto; border: 2px solid #fff; border-radius: 4px; }
    .best-container { text-align: center; margin-top: 20px; }
    #bestThumbnail { max-width: 100%; border: 3px solid #00aaff; border-radius: 4px; display: none; }
    #downloadLink { display: none; margin-top: 10px; text-decoration: none; color: #00ffcc; font-size: 18px; }
  </style>
</head>
<body>
  <div class="container">
    <h1>SuperPro Video Thumbnail Generator</h1>
    <div class="input-group">
      <input type="file" id="videoInput" accept="video/*">
      <select id="thumbnailCount">
        <option value="5">5 Thumbnails</option>
        <option value="10">10 Thumbnails</option>
        <option value="30" selected>30 Thumbnails</option>
        <option value="50">50 Thumbnails</option>
      </select>
      <button onclick="startExtraction()">Generate Thumbnails</button>
    </div>
    <div id="loader"></div>
    <div id="thumbnails"></div>
    <div class="best-container">
      <h2>Best Thumbnail</h2>
      <img id="bestThumbnail" alt="Best Thumbnail">
      <br>
      <a id="downloadLink" download="best_thumbnail.jpg">Download Best Thumbnail</a>
    </div>
  </div>
  <script>
    async function startExtraction() {
      document.getElementById("loader").innerText = "Processing...";
      document.getElementById("thumbnails").innerHTML = "";
      document.getElementById("bestThumbnail").style.display = "none";
      document.getElementById("downloadLink").style.display = "none";
      
      const file = document.getElementById("videoInput").files[0];
      if (!file) { alert("Please select a video file."); document.getElementById("loader").innerText = ""; return; }
      const count = parseInt(document.getElementById("thumbnailCount").value);
      const fileURL = URL.createObjectURL(file);
      
      // Sử dụng một video element tạm để lấy duration
      const tempVideo = document.createElement("video");
      tempVideo.src = fileURL;
      tempVideo.muted = true;
      await tempVideo.play();
      await new Promise(res => tempVideo.addEventListener("loadedmetadata", res));
      const duration = Math.min(tempVideo.duration, 300);
      let interval = 5;
      if (duration / count < 5) interval = duration / count;
      const times = [];
      for (let t = 0; t < duration && times.length < count; t += interval) {
        times.push(t);
      }
      
      // Đồng thời trích xuất frame cho mỗi timestamp
      const promises = times.map(time =>
        captureFrameAtTime(fileURL, time).then(dataURL => { displayThumbnail(dataURL); return dataURL; })
      );
      const images = await Promise.all(promises);
      
      const bestImage = await findBestThumbnail(images);
      document.getElementById("bestThumbnail").src = bestImage;
      document.getElementById("bestThumbnail").style.display = "block";
      const link = document.getElementById("downloadLink");
      link.href = bestImage;
      link.style.display = "inline-block";
      document.getElementById("loader").innerText = "";
    }
    
    function captureFrameAtTime(fileURL, time) {
      return new Promise((resolve, reject) => {
        const video = document.createElement("video");
        video.src = fileURL;
        video.muted = true;
        video.playsInline = true;
        video.addEventListener("loadedmetadata", () => {
          video.currentTime = time;
        });
        video.addEventListener("seeked", () => {
          const canvas = document.createElement("canvas");
          canvas.width = 1280;
          canvas.height = 720;
          const ctx = canvas.getContext("2d");
          ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
          resolve(canvas.toDataURL("image/jpeg"));
        });
        video.addEventListener("error", (e) => reject(e));
      });
    }
    
    function displayThumbnail(dataURL) {
      const container = document.getElementById("thumbnails");
      const img = new Image();
      img.src = dataURL;
      container.appendChild(img);
    }
    
    async function analyzeImage(dataURL) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = "Anonymous";
        img.src = dataURL;
        img.onload = () => {
          const tempCanvas = document.createElement("canvas");
          tempCanvas.width = img.width;
          tempCanvas.height = img.height;
          const ctx = tempCanvas.getContext("2d");
          ctx.drawImage(img, 0, 0);
          const data = ctx.getImageData(0, 0, tempCanvas.width, tempCanvas.height).data;
          let luminances = [];
          for (let i = 0; i < data.length; i += 4) {
            const r = data[i], g = data[i+1], b = data[i+2];
            const lum = 0.299 * r + 0.587 * g + 0.114 * b;
            luminances.push(lum);
          }
          const mean = luminances.reduce((a, b) => a + b, 0) / luminances.length;
          const variance = luminances.reduce((sum, lum) => sum + Math.pow(lum - mean, 2), 0) / luminances.length;
          const std = Math.sqrt(variance);
          resolve(std);
        };
        img.onerror = reject;
      });
    }
    
    async function findBestThumbnail(images) {
      let bestImage = images[0];
      let bestScore = -Infinity;
      for (const dataURL of images) {
        try {
          const score = await analyzeImage(dataURL);
          // Ảnh có độ tương phản cao hơn (std cao hơn) được xem là đẹp hơn
          if (score > bestScore) { bestScore = score; bestImage = dataURL; }
        } catch (e) { console.error(e); }
      }
      return bestImage;
    }
  </script>
</body>
</html>
