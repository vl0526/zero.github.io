<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>3D Racing Game Update 2.5</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    #hud { position: absolute; top: 10px; left: 10px; color: #fff; font-family: sans-serif; z-index: 10; font-size: 18px; }
    #control-buttons { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 10px; z-index: 10; }
    #control-buttons button { padding: 10px 20px; font-size: 16px; border: none; border-radius: 5px; background: rgba(255,255,255,0.8); cursor: pointer; }
    #control-buttons button:active { background: rgba(200,200,200,0.8); }
  </style>
</head>
<body>
  <div id="hud">Speed: 0 km/h</div>
  <div id="control-buttons">
    <button id="btn-up">↑</button>
    <button id="btn-left">←</button>
    <button id="btn-down">↓</button>
    <button id="btn-right">→</button>
  </div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
  <script src="https://threejs.org/examples/js/loaders/GLTFLoader.js"></script>
  <script>
    let scene, camera, renderer, hud;
    let world, vehicle, chassisBody, chassisMesh, carModel;
    let controls = { forward: false, backward: false, left: false, right: false, brake: false };
    let lastTime;
    
    init();
    animate();
    
    function init() {
      hud = document.getElementById('hud');
      scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x000000, 0.002);
      camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
      camera.position.set(0, 5, -10);
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);
      
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(10, 20, 10);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 1024;
      directionalLight.shadow.mapSize.height = 1024;
      scene.add(directionalLight);
      
      world = new CANNON.World();
      world.gravity.set(0, -9.82, 0);
      world.broadphase = new CANNON.NaiveBroadphase();
      world.solver.iterations = 10;
      
      const groundMaterial = new CANNON.Material("groundMaterial");
      const groundShape = new CANNON.Plane();
      const groundBody = new CANNON.Body({ mass: 0, material: groundMaterial });
      groundBody.addShape(groundShape);
      groundBody.quaternion.setFromEuler(-Math.PI/2, 0, 0);
      world.addBody(groundBody);
      
      const groundTexture = new THREE.TextureLoader().load("https://threejsfundamentals.org/threejs/resources/images/grasslight-big.jpg");
      groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
      groundTexture.repeat.set(50, 50);
      const groundGeo = new THREE.PlaneGeometry(500, 500);
      const groundMat = new THREE.MeshPhongMaterial({ map: groundTexture });
      const groundMesh = new THREE.Mesh(groundGeo, groundMat);
      groundMesh.rotation.x = -Math.PI/2;
      groundMesh.receiveShadow = true;
      scene.add(groundMesh);
      
      const chassisShape = new CANNON.Box(new CANNON.Vec3(1, 0.5, 2));
      chassisBody = new CANNON.Body({ mass: 150 });
      chassisBody.addShape(chassisShape);
      chassisBody.position.set(0, 2, 0);
      world.addBody(chassisBody);
      
      chassisMesh = new THREE.Mesh(new THREE.BoxGeometry(2, 1, 4), new THREE.MeshPhongMaterial({ color: 0x000000, visible: false }));
      chassisMesh.castShadow = true;
      scene.add(chassisMesh);
      
      vehicle = new CANNON.RaycastVehicle({ chassisBody: chassisBody });
      const wheelOptions = {
        radius: 0.4,
        directionLocal: new CANNON.Vec3(0, -1, 0),
        suspensionStiffness: 40,
        suspensionRestLength: 0.3,
        frictionSlip: 5,
        dampingRelaxation: 2.3,
        dampingCompression: 4.4,
        maxSuspensionForce: 100000,
        rollInfluence: 0.01,
        axleLocal: new CANNON.Vec3(-1, 0, 0),
        chassisConnectionPointLocal: new CANNON.Vec3(),
        maxSuspensionTravel: 0.3,
        customSlidingRotationalSpeed: -30,
        useCustomSlidingRotationalSpeed: true
      };
      const axleWidth = 1.0;
      const wheelPositions = [
        new CANNON.Vec3(-axleWidth, 0, 1.5),
        new CANNON.Vec3(axleWidth, 0, 1.5),
        new CANNON.Vec3(-axleWidth, 0, -1.5),
        new CANNON.Vec3(axleWidth, 0, -1.5)
      ];
      for (let pos of wheelPositions) {
        wheelOptions.chassisConnectionPointLocal.copy(pos);
        vehicle.addWheel(wheelOptions);
      }
      vehicle.addToWorld(world);
      
      window.addEventListener('resize', onWindowResize);
      window.addEventListener('keydown', onKeyDown);
      window.addEventListener('keyup', onKeyUp);
      setupControlButtons();
      loadCarModel();
    }
    
    function loadCarModel() {
      const loader = new THREE.GLTFLoader();
      loader.load(
        'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/CesiumMilkTruck/glTF/CesiumMilkTruck.gltf',
        function(gltf) {
          carModel = gltf.scene;
          carModel.scale.set(0.5, 0.5, 0.5);
          carModel.traverse(child => { if(child.isMesh){ child.castShadow = true; child.receiveShadow = true; } });
          chassisMesh.add(carModel);
        },
        undefined,
        function(error) { console.error(error); }
      );
    }
    
    function onWindowResize() {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    function onKeyDown(e) {
      switch(e.code) {
        case 'ArrowUp': controls.forward = true; break;
        case 'ArrowDown': controls.backward = true; break;
        case 'ArrowLeft': controls.left = true; break;
        case 'ArrowRight': controls.right = true; break;
        case 'Space': controls.brake = true; break;
      }
    }
    
    function onKeyUp(e) {
      switch(e.code) {
        case 'ArrowUp': controls.forward = false; break;
        case 'ArrowDown': controls.backward = false; break;
        case 'ArrowLeft': controls.left = false; break;
        case 'ArrowRight': controls.right = false; break;
        case 'Space': controls.brake = false; break;
      }
    }
    
    function setupControlButtons() {
      const btnUp = document.getElementById('btn-up'),
            btnDown = document.getElementById('btn-down'),
            btnLeft = document.getElementById('btn-left'),
            btnRight = document.getElementById('btn-right');
      
      btnUp.addEventListener('mousedown', () => controls.forward = true);
      btnUp.addEventListener('mouseup', () => controls.forward = false);
      btnUp.addEventListener('touchstart', () => controls.forward = true);
      btnUp.addEventListener('touchend', () => controls.forward = false);
      
      btnDown.addEventListener('mousedown', () => controls.backward = true);
      btnDown.addEventListener('mouseup', () => controls.backward = false);
      btnDown.addEventListener('touchstart', () => controls.backward = true);
      btnDown.addEventListener('touchend', () => controls.backward = false);
      
      btnLeft.addEventListener('mousedown', () => controls.left = true);
      btnLeft.addEventListener('mouseup', () => controls.left = false);
      btnLeft.addEventListener('touchstart', () => controls.left = true);
      btnLeft.addEventListener('touchend', () => controls.left = false);
      
      btnRight.addEventListener('mousedown', () => controls.right = true);
      btnRight.addEventListener('mouseup', () => controls.right = false);
      btnRight.addEventListener('touchstart', () => controls.right = true);
      btnRight.addEventListener('touchend', () => controls.right = false);
    }
    
    function animate(time) {
      requestAnimationFrame(animate);
      if(lastTime !== undefined) {
        let dt = (time - lastTime) / 1000;
        const maxEngineForce = 300;
        let engineForce = 0;
        if(controls.forward) engineForce = -maxEngineForce;
        if(controls.backward) engineForce = maxEngineForce;
        let brakeForce = controls.brake ? 100 : 0;
        vehicle.applyEngineForce(engineForce, 0);
        vehicle.applyEngineForce(engineForce, 1);
        for(let i = 0; i < 4; i++) { vehicle.setBrake(brakeForce, i); }
        let steerVal = 0;
        const maxSteerVal = 0.5;
        if(controls.left) steerVal = maxSteerVal;
        if(controls.right) steerVal = -maxSteerVal;
        vehicle.setSteeringValue(steerVal, 0);
        vehicle.setSteeringValue(steerVal, 1);
        world.step(1/60, dt, 3);
      }
      lastTime = time;
      
      chassisMesh.position.copy(chassisBody.position);
      chassisMesh.quaternion.copy(chassisBody.quaternion);
      
      const relativeCameraOffset = new THREE.Vector3(0, 5, -12);
      const cameraOffset = relativeCameraOffset.applyMatrix4(chassisMesh.matrixWorld);
      camera.position.lerp(cameraOffset, 0.05);
      camera.lookAt(chassisMesh.position);
      
      const speed = chassisBody.velocity.length();
      hud.innerHTML = "Speed: " + Math.round(speed * 3.6) + " km/h";
      
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
