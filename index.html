<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Trích Xuất Thumbnail Video</title>
  <style>
    body { font-family: Arial, sans-serif; text-align: center; background: #000; color: #fff; }
    button, input, select { padding: 10px; margin: 10px; cursor: pointer; border: none; font-size: 16px; }
    button { background: #00aaff; color: #fff; }
    #thumbnails img { width: 120px; height: auto; margin: 5px; border: 2px solid #fff; }
    #bestThumbnail { max-width: 640px; display: none; margin-top: 20px; }
    #downloadLink { display: none; color: #00ffcc; font-size: 18px; text-decoration: none; }
  </style>
</head>
<body>
  <h2>Trích Xuất & Chọn Thumbnail Đẹp Nhất</h2>
  <input type="file" id="videoInput" accept="video/*">
  <select id="thumbnailCount">
    <option value="5">5 Ảnh</option>
    <option value="10">10 Ảnh</option>
    <option value="30" selected>30 Ảnh</option>
    <option value="50">50 Ảnh</option>
  </select>
  <button onclick="startExtraction()">Bắt Đầu</button>
  <div id="thumbnails"></div>
  <h3>Ảnh Đẹp Nhất:</h3>
  <img id="bestThumbnail">
  <a id="downloadLink" download="best_thumbnail.jpg">Tải Ảnh Đẹp Nhất</a>

  <script>
    // Ngưỡng Hamming distance để coi ảnh là trùng lặp
    const DUPLICATE_THRESHOLD = 10;
    
    async function startExtraction() {
      const file = document.getElementById("videoInput").files[0];
      if (!file) return alert("Chọn video trước!");
      
      // Tạo video tạm để lấy duration
      const tempVideo = document.createElement("video");
      tempVideo.src = URL.createObjectURL(file);
      tempVideo.muted = true;
      await tempVideo.play();
      await new Promise(res => tempVideo.addEventListener("loadedmetadata", res));
      
      const duration = Math.min(tempVideo.duration, 300);
      const desiredCount = parseInt(document.getElementById("thumbnailCount").value);
      const baseInterval = 5;
      let interval = baseInterval;
      if(duration / desiredCount < baseInterval) {
        interval = duration / desiredCount;
      }
      
      // Khởi tạo danh sách thời điểm ban đầu
      let times = [];
      for (let t = 0; t < duration && times.length < desiredCount; t += interval) {
        times.push(t);
      }
      
      const uniqueImages = [];
      // Sử dụng hàm async để trích xuất liên tục cho đến khi đủ ảnh duy nhất hoặc hết video
      let currentIndex = 0;
      while(uniqueImages.length < desiredCount && currentIndex < times.length) {
        const dataURL = await captureFrameAtTime(URL.createObjectURL(file), times[currentIndex]);
        const hash = await getImageHash(dataURL);
        if(!isDuplicate(hash, uniqueImages)) {
          uniqueImages.push({ src: dataURL, hash });
          displayThumbnail(dataURL);
        }
        currentIndex++;
      }
      // Nếu chưa đủ, thử tiếp các thời điểm sau cùng
      let extraTime = times[times.length - 1] + interval;
      while(uniqueImages.length < desiredCount && extraTime < duration) {
        const dataURL = await captureFrameAtTime(URL.createObjectURL(file), extraTime);
        const hash = await getImageHash(dataURL);
        if(!isDuplicate(hash, uniqueImages)) {
          uniqueImages.push({ src: dataURL, hash });
          displayThumbnail(dataURL);
        }
        extraTime += interval;
      }
      
      // Sau khi có danh sách ảnh duy nhất, chọn ảnh đẹp nhất dựa trên độ tương phản (std luminance)
      const bestImage = await findBestThumbnail(uniqueImages.map(item => item.src));
      document.getElementById("bestThumbnail").src = bestImage;
      document.getElementById("bestThumbnail").style.display = "block";
      const link = document.getElementById("downloadLink");
      link.href = bestImage;
      link.style.display = "block";
    }
    
    function captureFrameAtTime(fileURL, time) {
      return new Promise((resolve, reject) => {
        const video = document.createElement("video");
        video.src = fileURL;
        video.muted = true;
        video.playsInline = true;
        video.addEventListener("loadedmetadata", () => {
          video.currentTime = time;
        });
        video.addEventListener("seeked", () => {
          const canvas = document.createElement("canvas");
          canvas.width = 1280;
          canvas.height = 720;
          const ctx = canvas.getContext("2d");
          ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
          resolve(canvas.toDataURL("image/jpeg"));
        });
        video.addEventListener("error", (e) => reject(e));
      });
    }
    
    function displayThumbnail(dataURL) {
      const container = document.getElementById("thumbnails");
      const img = new Image();
      img.src = dataURL;
      container.appendChild(img);
    }
    
    async function getImageHash(dataURL) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = "Anonymous";
        img.src = dataURL;
        img.onload = () => {
          const size = 8;
          const canvas = document.createElement("canvas");
          canvas.width = size;
          canvas.height = size;
          const ctx = canvas.getContext("2d");
          ctx.drawImage(img, 0, 0, size, size);
          const imageData = ctx.getImageData(0, 0, size, size).data;
          const pixels = [];
          for(let i = 0; i < imageData.length; i += 4) {
            const brightness = (imageData[i] + imageData[i+1] + imageData[i+2]) / 3;
            pixels.push(brightness);
          }
          const avg = pixels.reduce((a,b)=>a+b,0) / pixels.length;
          let hash = "";
          pixels.forEach(p => {
            hash += (p >= avg) ? "1" : "0";
          });
          resolve(hash);
        };
        img.onerror = reject;
      });
    }
    
    function hammingDistance(hash1, hash2) {
      let dist = 0;
      for(let i = 0; i < hash1.length; i++){
        if(hash1[i] !== hash2[i]) dist++;
      }
      return dist;
    }
    
    // Kiểm tra xem hash của ảnh mới có trùng với ảnh nào trong danh sách chưa
    function isDuplicate(newHash, images) {
      for(const item of images) {
        if(hammingDistance(newHash, item.hash) < DUPLICATE_THRESHOLD) return true;
      }
      return false;
    }
    
    async function analyzeImage(dataURL) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = "Anonymous";
        img.src = dataURL;
        img.onload = () => {
          const tempCanvas = document.createElement("canvas");
          tempCanvas.width = img.width;
          tempCanvas.height = img.height;
          const ctx = tempCanvas.getContext("2d");
          ctx.drawImage(img, 0, 0);
          const data = ctx.getImageData(0, 0, tempCanvas.width, tempCanvas.height).data;
          let luminances = [];
          for(let i = 0; i < data.length; i += 4){
            const r = data[i], g = data[i+1], b = data[i+2];
            const lum = 0.299*r + 0.587*g + 0.114*b;
            luminances.push(lum);
          }
          const mean = luminances.reduce((a,b) => a+b, 0) / luminances.length;
          const variance = luminances.reduce((sum, lum) => sum + Math.pow(lum - mean, 2), 0) / luminances.length;
          resolve(Math.sqrt(variance));
        };
        img.onerror = reject;
      });
    }
    
    async function findBestThumbnail(images) {
      let bestImage = images[0];
      let bestScore = -Infinity;
      for(const src of images) {
        try {
          const score = await analyzeImage(src);
          if(score > bestScore) { bestScore = score; bestImage = src; }
        } catch(e) { console.error(e); }
      }
      return bestImage;
    }
  </script>
</body>
</html>
