<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Trích Xuất Thumbnail Video</title>
  <style>
    body { font-family: Arial, sans-serif; text-align: center; background: #000; color: #fff; }
    button, input, select { padding: 10px; margin: 10px; cursor: pointer; border: none; font-size: 16px; }
    button { background: #00aaff; color: #fff; }
    #thumbnails img { width: 120px; height: auto; margin: 5px; border: 2px solid #fff; }
    #bestThumbnail { max-width: 640px; display: none; margin-top: 20px; }
    #downloadLink { display: none; color: #00ffcc; font-size: 18px; text-decoration: none; }
  </style>
</head>
<body>
  <h2>Trích Xuất & Chọn Thumbnail Đẹp Nhất</h2>
  <input type="file" id="videoInput" accept="video/*">
  <select id="thumbnailCount">
    <option value="5">5 Ảnh</option>
    <option value="10">10 Ảnh</option>
    <option value="30" selected>30 Ảnh</option>
    <option value="50">50 Ảnh</option>
  </select>
  <button onclick="extractThumbnails()">Bắt Đầu</button>
  <div id="thumbnails"></div>
  <h3>Ảnh Đẹp Nhất:</h3>
  <img id="bestThumbnail">
  <a id="downloadLink" download="best_thumbnail.jpg">Tải Ảnh Đẹp Nhất</a>
  
  <script>
    const DUPLICATE_THRESHOLD = 10; // Ngưỡng Hamming distance
    const MIN_CONTRAST = 20; // Ngưỡng độ tương phản tối thiểu

    async function extractThumbnails() {
      const file = document.getElementById("videoInput").files[0];
      if (!file) return alert("Chọn video trước!");
      const desiredCount = parseInt(document.getElementById("thumbnailCount").value);
      const videoURL = URL.createObjectURL(file);
      const video = document.createElement("video");
      video.src = videoURL;
      video.muted = true;
      await video.play();
      await new Promise(res => video.addEventListener("loadedmetadata", res));
      
      const duration = Math.min(video.duration, 300);
      const baseInterval = 5;
      let interval = baseInterval;
      if(duration / desiredCount < baseInterval) interval = duration / desiredCount;
      
      // Mảng các thời điểm ban đầu
      let times = [];
      for (let t = 0; t < duration; t += interval) {
        times.push(t);
      }
      
      let uniqueImages = await extractUniqueFrames(video, times, videoURL);
      
      // Nếu chưa đủ, tiếp tục trích xuất thêm từ thời điểm sau cùng
      let extraTime = times[times.length - 1] + interval;
      while(uniqueImages.length < desiredCount && extraTime < duration) {
        try {
          const dataURL = await captureFrameAtTime(video, extraTime);
          const contrast = await analyzeImage(dataURL).catch(() => 0);
          if (contrast < MIN_CONTRAST) { extraTime += interval; continue; }
          const hash = await getImageHash(dataURL).catch(() => "");
          if (!isDuplicate(hash, uniqueImages)) {
            uniqueImages.push({ src: dataURL, hash });
            displayThumbnail(dataURL);
          }
        } catch (e) { /* Bỏ qua lỗi */ }
        extraTime += interval;
      }
      
      if(uniqueImages.length === 0) return alert("Không trích xuất được ảnh phù hợp.");
      
      const bestImage = await findBestThumbnail(uniqueImages.map(item => item.src));
      document.getElementById("bestThumbnail").src = bestImage;
      document.getElementById("bestThumbnail").style.display = "block";
      const link = document.getElementById("downloadLink");
      link.href = bestImage;
      link.style.display = "inline-block";
    }
    
    async function extractUniqueFrames(video, times, fileURL) {
      let uniqueImages = [];
      for (let t of times) {
        try {
          const dataURL = await captureFrameAtTime(video, t);
          const contrast = await analyzeImage(dataURL).catch(() => 0);
          if (contrast < MIN_CONTRAST) continue;
          const hash = await getImageHash(dataURL).catch(() => "");
          if (!isDuplicate(hash, uniqueImages)) {
            uniqueImages.push({ src: dataURL, hash });
            displayThumbnail(dataURL);
          }
        } catch(e) { continue; }
      }
      return uniqueImages;
    }
    
    function captureFrameAtTime(video, time) {
      return new Promise((resolve, reject) => {
        video.currentTime = time;
        video.onseeked = () => {
          const canvas = document.createElement("canvas");
          canvas.width = 1280;
          canvas.height = 720;
          const ctx = canvas.getContext("2d");
          ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
          resolve(canvas.toDataURL("image/jpeg"));
        };
        video.onerror = reject;
      });
    }
    
    function displayThumbnail(dataURL) {
      const container = document.getElementById("thumbnails");
      const img = new Image();
      img.src = dataURL;
      container.appendChild(img);
    }
    
    async function analyzeImage(dataURL) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = "Anonymous";
        img.src = dataURL;
        img.onload = function() {
          const tempCanvas = document.createElement("canvas");
          tempCanvas.width = img.width;
          tempCanvas.height = img.height;
          const ctx = tempCanvas.getContext("2d");
          ctx.drawImage(img, 0, 0);
          const data = ctx.getImageData(0, 0, tempCanvas.width, tempCanvas.height).data;
          let luminances = [];
          for (let i = 0; i < data.length; i += 4) {
            const r = data[i], g = data[i+1], b = data[i+2];
            const lum = 0.299 * r + 0.587 * g + 0.114 * b;
            luminances.push(lum);
          }
          const mean = luminances.reduce((a, b) => a + b, 0) / luminances.length;
          const variance = luminances.reduce((sum, lum) => sum + Math.pow(lum - mean, 2), 0) / luminances.length;
          resolve(Math.sqrt(variance));
        };
        img.onerror = reject;
      });
    }
    
    async function getImageHash(dataURL) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = "Anonymous";
        img.src = dataURL;
        img.onload = () => {
          const size = 8;
          const canvas = document.createElement("canvas");
          canvas.width = size;
          canvas.height = size;
          const ctx = canvas.getContext("2d");
          ctx.drawImage(img, 0, 0, size, size);
          const imageData = ctx.getImageData(0, 0, size, size).data;
          const pixels = [];
          for (let i = 0; i < imageData.length; i += 4) {
            const brightness = (imageData[i] + imageData[i+1] + imageData[i+2]) / 3;
            pixels.push(brightness);
          }
          const avg = pixels.reduce((a, b) => a + b, 0) / pixels.length;
          let hash = "";
          pixels.forEach(p => { hash += (p >= avg) ? "1" : "0"; });
          resolve(hash);
        };
        img.onerror = reject;
      });
    }
    
    function hammingDistance(hash1, hash2) {
      let dist = 0;
      for (let i = 0; i < hash1.length; i++) {
        if (hash1[i] !== hash2[i]) dist++;
      }
      return dist;
    }
    
    function isDuplicate(newHash, images) {
      for (const item of images) {
        if (hammingDistance(newHash, item.hash) < DUPLICATE_THRESHOLD) return true;
      }
      return false;
    }
    
    async function findBestThumbnail(images) {
      let bestImage = images[0];
      let bestScore = -Infinity;
      for (const src of images) {
        try {
          const score = await analyzeImage(src);
          if (score > bestScore) { bestScore = score; bestImage = src; }
        } catch(e) { console.error(e); }
      }
      return bestImage;
    }
  </script>
</body>
</html>
